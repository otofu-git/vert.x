<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link href="bootstrap/bootstrap.css" type="text/css" rel="stylesheet"/>

  <link href="google-code-prettify/prettify.css" type="text/css" rel="stylesheet"/>
  <script type="text/javascript" src="google-code-prettify/prettify.js"></script>
  <link href="css/vertx.css" type="text/css" rel="stylesheet"/>
  <link href="css/sunburst.css" type="text/css" rel="stylesheet"/>
  <title>Vert.x 웹 어플리케이션 튜토리얼</title>
  <script>
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-35733016-2']);
    _gaq.push(['_trackPageview']);
    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
</head>

<body onload="prettyPrint()">

<div class="navbar navbar-fixed-top">
  <div class="navbar-inner">
    <div class="container">

      <a class="btn btn-navbar" data-toggle="collapse"
         data-target=".nav-collapse">
        <span class="i-bar"></span>
        <span class="i-bar"></span>
        <span class="i-bar"></span>
      </a>

      <a class="brand" href="/">vert.x</a>

      <div class="nav-collapse">
        <ul class="nav">
          <li><a href="/">홈</a></li>
          <li><a href="downloads.html">다운로드</a></li>
          <li><a href="install.html">설치</a></li>
          <li class="active"><a href="tutorials.html">튜토리얼</a></li>
          <li><a href="examples.html">예제</a></li>
          <li><a href="docs.html">문서</a></li>
          <li><a href="https://github.com/vert-x/vert.x">코드</a></li>
          <li><a href="http://groups.google.com/group/vertx">구글 그룹</a></li>
          <li><a href="community.html">커뮤니티</a></li>
          <li><a href="http://vertxproject.wordpress.com/">블로그</a></li>
        </ul>
      </div>
    </div>
  </div>
</div>

<div class="container">

  <div class="row">
    <div class="span12">
      <div class="well">
        <h1 style="font-size: 35px;">자바스크립트 웹 어플리케이션 만들기</h1>
      </div>
    </div>
  </div>

  <div class="row">
    <div class="span12">
      <div class="well">
<div>


<p>자 vert.x 를 이용해서 실시간 웹 어플리케이션을 만들어 봅시다.</p>
<p>우리는 "vToons" 라는 음반 쇼핑 어플리케이션을 만들 겁니다.</p>
<p>이 어플리케이션의 구조는 굉장히 간단합니다. 서버의 vert.x 이벤트 버스와 persistor 모듈, 클라이언트측 JavaScript MVVM (MVC) 어플리케이션이 통신하는 구조로 구성되어 있습니다. persistor 모듈은 음반 상품을 저장하고 주문을 처리하는데 쓰입니다.</p>
<p>또한 html, css 그리고 js파일과 같은 정적인 파일들을 출력하는 웹 서버 모듈이 있습니다.</p>
<p><strong>이 어플리케이션을 위해 따로 모듈을 만들 필요는 없습니다</strong>. 로컬로 작동하는 클라이언트 자바스크립트와 통신하는 persistor 만 구현하면 됩니다.</p>
<p>당신은 서버에 persistor와 웹 서버를 시작하게 하는 간단한 스크립트만 작성하면 됩니다. 이 스크립트에는 어플리케이션에 필요한 설정을 포함시킬수 도 있습니다.</p>
<p>이 튜토리얼은 자바스크립트로 이용하는 유저를 위해 작성되었습니다. Ruby나 Groovy를 이용해 ver.x를 작동시키고 싶다면 해당 언어의 튜토리얼을 참고하세요.</p>
<p>완성된 코드를 돌려보기만 하고 싶다면 배포판 내에 있는 예제 중 <code>webapp</code> 디렉토리의 파일을 이용하세요. README 파일에 어떻게 예제 코드를 실행시킬 수 있는지 나와있습니다.</p>
<p>이 코드는 <a href="https://github.com/vert-x/vert.x/tree/master/vertx-examples/src/main/javascript/webapp">github</a> 에서도 볼 수 있습니다.</p>
<h2 id="step-1-install-vertx">1 단계. Vert.x 설치하기</h2><br/>
<p>아직 vert.x 설치를 안하셨나요? <a href="install.html">그럼 여기에서 설치합니다</a>. </p>
<p>다음 부분부터는 vert.x 를 <code>VERTX_HOME</code> 에 설치한 것으로 간주하고 진행합니다.</p>
<h2 id="step-2-get-the-web-server-running">2단계. 서버 돌리기</h2><br/>
<p>정적인 파일들을 출력하기 위해 웹 서버가 필요합니다. Vert.x 에서 몇 줄의 코드로 웹 서버를 만들 수 있습니다. 하지만 그럴 필요조차 없습니다. Vert.x 에는 아주 좋은 웹 서버 모듈이 있습니다. 우린 그걸 이용할 겁니다.</p>
<p>웹 서버를 구성하고 시작하는 스크립트를 작성해 봅시다.</p>
<p>텍스트 에디터를 열어서 다음 코드를 복사해 넣어봅시다.</p>
<pre class="prettyprint">load('vertx.js');

var webServerConf = {  
  port: 8080,
  host: 'localhost'
};

// Start the web server, with the config we defined above

vertx.deployModule('vertx.web-server-v1.0', webServerConf);
</pre>
<p><code>deployModule</code> 을 호출해서 <code>vertx.web-server</code> 모듈의 인스턴스를 deploy 합니다. 모듈이 설치되어 있지 않다면 vert.x는 저장소를 통해 모듈을 자동으로 설치할 겁니다. 모듈에 대한 자세한 정보는 모듈 매뉴얼을 참고하도록 합시다.</p>
<p><code>app.js</code> 로 저장합니다.</p>
<p>이제 <code>web</code> 이라는 디렉토리를 만들고 그 안에 <code>index.html</code> 파일을 넣습니다.</p>
<pre class="prettyprint">mkdir web
echo "&lt;html&gt;&lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt;" &gt; web/index.html
</pre>
<p>그리고 서버를 돌려봅시다.</p>
<pre class="prettyprint">vertx run app.js
</pre>
<p>브라우저에서 <code>http://localhost:8080</code> 를 열어 봅시다. 'Hello World' 라는 문구가 나오는 페이지가 열릴겁니다.  <br/>
</p>
<p>자 웹 서버가 만들어 졌습니다.</p>
<h2 id="step-3-serve-the-client-side-app">3 단계. 클라이언트 측 application 만들기</h2><br/>
<p>잘 돌아가는 웹 서버를 만들었고 이제 클라이언트 측 어플리케이션을 만들어 보도록 하죠.</p>
<p>이 예제에서는 <a href="http://knockoutjs.com/">knockout.js</a> 와 <a href="http://twitter.github.com/bootstrap/">Twitter bootstrap</a> 을 이용해 어플리케이션을 작성할 겁니다. 하지만 당신이 사용하기 편리한 다른 어떤 스크립트 툴을 이용해도 상관없습니다. (예를들면 jQuery, backbone.js, ember.js 등등).</p>
<p>이 튜토리얼에서는 knockout.js 나 Twitter bootstrap 가 어떻게 작동하고 이들을 어떻게 다루는지는 설명하지 않을겁니다.</p>
<p>다음처럼 vert.x 설치 경로에서 web 디렉토리를 복사합시다.</p>
<pre class="prettyprint">cp -r $VERTX_HOME/examples/javascript/webapp/web/* web
</pre>
<p>이제 브라우저에서 페이지를 새로고침 해봅시다. 클라이언트 측 어플리케이션이 나타날 겁니다.</p>
<p>당연히 아직 아무 쓸만한 기능도 제공하지 않습니다. 아무것도 연결한게 없으니까요. 그래도 레이아웃을 볼 수는 있습니다. 다음처럼 보이겠죠.</p>
<p><img alt="Client Application" src="tutorial_1.png"/></p>
<p>잠시 이것저것 클릭해 봅시다. 어플리케이션을 이해하는데 도움이 될 겁니다.</p>
<p>가운데에는 상품과 장바구니를 조회할 수 있는 각각의 탭이 위치해 있습니다.</p>
<p>왼쪽에는 로그인 할 수 있는 폼이 있네요.<br/>
</p>
<h3 id="step-4-get-the-persistor-up-and-running">4단계. Persistor 를 올리고 실행시키기</h3><br/>
<p>Vert.x 모듈 저장소에는 <code>vertx.mongo-persistor</code> 라는 모듈이 있습니다. </p>
<p>이 모듈을 가지고 MongoDB 데이터베이스에서 데이터를 저장/수정/삭제/검색 할 수 있습니다. (모듈의 자세한 정보는 모듈 매뉴얼을 참고하세요.)</p>
<p>우리는 이 persistor 를 이용해 어플리케이션을 살짝 바꿔볼 겁니다.</p>
<ul>
<li>음반의 카탈로그를 저장</li>
<li>사용자의 이름과 비밀번호를 저장</li>
<li>주문을 저장</li>
</ul>
<p>Persistor 를 시작하기 위해 <code>app.js</code> 를 다음과 같이 수정합니다.</p>
<pre class="prettyprint">load('vertx.js');

var webServerConf = {  
  port: 8080,
  host: 'localhost'
};

// Start a MongoDB persistor module

vertx.deployModule('vertx.mongo-persistor-v1.0');

// Start the web server, with the config we defined above

vertx.deployModule('vertx.web-server-v1.0', webServerConf);
</pre>
<p>물론 MongoDB 인스턴스가 로컬에 기본설정으로 제대로 설치되어 있어야 합니다.</p>
<p>먼저 실행한 서버를 CTRL-C 로 정지시키고 다시 <code>app.js</code> 를 실행시킵니다.</p>
<pre class="prettyprint">vertx run app.js
</pre>
<p>Persistor 와 웹 서버가 돌아가고 웹 서버는 이전 처럼 클라이언트 어플리케이션을 제공할 겁니다.</p>
<h2 id="step-5-connecting-up-the-client-side-to-the-event-bus">5단계. 클라이언트를 Event Bus 로 연결하기</h2><br/>
<p>지금까지 웹 서버를 만들어 돌렸지만 서버측 persistor는 event bus를 기다릴 뿐 아무동작도 하지 않았습니다.</p>
<p>클라이언트 측과 연결해 event bus 를 통해 persistor와 상호작용 할 수 있게 만들어 봅시다.</p>
<p>우리는 SockJS 브릿지를 이용할 겁니다.</p>
<p>SockJS 기술을 통해 브라우저와 서버가 웹소켓처럼 전이중 통신을 할겁니다. 브라우저나 네트워크가 웹 소켓을 지원하지 않더라도요.</p>
<p>Vert.x API 를 이용해 SockJS 서버를 직접 만들수 있습니다. (API 매뉴얼에 자세한 내용이 있습니다.), 하지만 <code>vertx.web-server</code> 모듈안에 브릿지 기능이 포함되어 있습니다. 우리는 이 기능을 활성화 시켜주기만 하면 됩니다.</p>
<p>웹 서버 설정을 다음처럼 수정합니다.</p>
<pre class="prettyprint">var webServerConf = {  
  port: 8080,
  host: 'localhost',
  bridge: true,

  inbound_permitted: [
    {
      address : 'vertx.mongopersistor',
      match : {
        action : 'find',
        collection : 'albums'
      }
    }
  ],
  outbound_permitted: [ {} ]
};
</pre>
<p>Setting the <code>bridge</code> field to <code>true</code> tells the web server to also act like an event bus bridge as well as serving static files.</p>
<p>The other new things here are the <code>inbound_permitted</code> and <code>outbound_permitted</code> fields. These are arrays of JSON objects which determine which event bus messages we're going to allow through the client side. The bridge basically acts like a firewall and only allows through those messages that we want to come through. <code>inbound_permitted</code> determines which messages we are going to allow from the client --&gt; server, and <code>outbound_permitted</code> determines which messages we are going to allow from server --&gt; client.</p>
<p>If we allowed the client to send any messages to the persistor, it would be able to do things like delete all data in the database, or perhaps view data it is not entitled to see.</p>
<p>(For detailed information on how the firewall works, please see the core documentation.)</p>
<p>Initially, we only want to allow through requests to the persistor to load the album data. This will be used by the client side application to display the list of available items to buy.</p>
<p>The above configuration will only allow messages from the client that are addressed to <code>vertx.mongopersistor</code> (that's the event bus address of the MongoDB persistor), and which have a field <code>action</code> with a value <code>find</code>, and a field <code>collection</code> with a value <code>albums</code>.</p>
<p>Save the file.</p>
<h2 id="step-6-inserting-the-static-data">Step 6. Inserting the Static Data</h2><br/>
<p>We're almost at the point where the client side app can see the catalogue data. But first we need to insert some static data.</p>
<p>To do this we need a script which inserts catalogue and other data needed by the application in the database. It does this by sending JSON messages on the event bus to the persistor.</p>
<p>Copy <code>static_data.js</code> into your directory as follows:</p>
<pre class="prettyprint">cp $VERTX_HOME/examples/javascript/webapp/static_data.js .
</pre>
<p>We want to insert the static data only after the persistor verticle has completed starting up so we edit <code>app.js</code> as follows:</p>
<pre class="prettyprint">vertx.deployModule('vertx.mongo-persistor-v1.0', null, 1, function() {
  load('static_data.js');
});
</pre>
<p>The function that we're specifying in the call to <code>deployModule</code> won't be invoked until the persistor is fully started. In that function we just load the static data script.</p>
<p>Save the edited <code>app.js</code> and restart it.</p>
<pre class="prettyprint">vertx run app.js
</pre>
<p>Refresh your browser.</p>
<p>You should now see the catalogue displayed in the client side app:</p>
<p><img alt="Client Application" src="tutorial_2.png"/><br/>
</p>
<p>Now there is some stuff to buy, you should be able to add stuff to your cart, and view the contents of your cart by clicking on the cart tab.</p>
<h2 id="step-7-requesting-data-from-the-server">Step 7. Requesting data from the server</h2><br/>
<p>As previously mentioned, this isn't a tutorial on how to write a knockout.js client-side application, but let's take a quick look at the code in the client side app that requests the catalogue data and populates the shop.</p>
<p>The client side application JavaScript is contained in the file <code>web/js/client_app.js</code>. If you open this in your text editor you will see the following line, towards the top of the script:</p>
<pre class="prettyprint">var eb = new vertx.EventBus(window.location.protocol + '//' + window.location.hostname + ':' + window.location.port + '/eventbus');
</pre>
<p>This is using the <code>vertxbus.js</code> library to create an <code>EventBus</code> object. This object is then used to send and receive messages from the event bus.</p>
<p>If you look a little further down the script, you will find the part which loads the catalogue data from the server and renders it:</p>
<pre class="prettyprint">eb.onopen = function() {

    // Get the static data

    eb.send('vertx.mongopersistor', {action: 'find', collection: 'albums', matcher: {} },
      function(reply) {
        if (reply.status === 'ok') {
          var albumArray = [];
          for (var i = 0; i &lt; reply.results.length; i++) {
            albumArray[i] = new Album(reply.results[i]);
          }
          that.albums = ko.observableArray(albumArray);
          ko.applyBindings(that);
        } else {
          console.error('Failed to retrieve albums: ' + reply.message);
        }
      });
  };
</pre>
<p>The <code>onopen</code> is called when, unsurprisingly, the event bus connection is fully setup and open.<br/>
</p>
<p>At that point we are calling the <code>send</code> function on the event bus to a send a JSON message to the address <code>vertx.mongopersistor</code>. This is the address of the MongoDB persistor module that we configured earlier.</p>
<p>The JSON message that we're sending specifies that we want to find and return all albums in the database. (For a full description of the operations that the MongoDBPersistor module expects you can consult the README.md in the <code>mod-mongo-persistor</code> repository).</p>
<p>The final argument that we pass to to <code>send</code> is a reply handler. This is a function that gets called when the persistor has processed the operation and sent the reply back here. The first argument to the reply handler is the reply itself.</p>
<p>In this case, the reply contains a JSON message with a field <code>results</code> which contains a JSON array containing the albums.</p>
<p>Once we get the albums we give them to knockout.js to render on the view.</p>
<h2 id="step-8-handling-login">Step 8. Handling Login</h2><br/>
<p>In order to actually send an order, you need to be logged in.</p>
<p>To handle login we will start an instance of the <code>vertx.auth-mgr</code> which lives in the repository. This is a simple module which handles simple user/password authentication and authorisation. Users credentials are stored in the MongoDB database. Fore more sophisticated auth, you can easily write your own auth module and the bridge can talk to that instead.</p>
<p>To login, the client sends a message on the event bus to the address <code>vertx.basicauthmanager.login</code> with fields <code>username</code> and <code>credentials</code>, and if successful it replies with a message containing a unique session id, in the <code>sessionID</code> field.</p>
<p>This session id should then be sent in any subsequent message from the client to the server that requires authentication (e.g. persisting an order).</p>
<p>When the bridge receives a message with a <code>sessionID</code> field in it, it will contact the auth manager to see if the session is authorised for that resource.</p>
<p>Let's add a line to start the <code>auth-mgr</code>:</p>
<p>Edit <code>app.js</code> and add the following, just after where the Mongo Persistor is deployed.</p>
<pre class="prettyprint">// Deploy an auth manager to handle the authentication

vertx.deployModule('vertx.auth-mgr-v1.0');
</pre>
<p>We'll also need to tell the bridge to let through any login messages:</p>
<pre class="prettyprint">inbound_permitted: [
  // Allow calls to login and authorise
  {
    address: 'vertx.basicauthmanager.login'
  },
  ...
</pre>
<p>Save, and restart the app.</p>
<p>You can test login by attempting to log-in with username <code>tim</code> and password <code>password</code>. A message should appear on the left telling you you are logged in!</p>
<p><img alt="Client Application" src="tutorial_3.png"/></p>
<p>Let's take a look at the client side code which does the login.</p>
<p>Open <code>web/js/client_app.js</code> and scroll down to the <code>login</code> function. This gets trigged by knockout when the login button is pressed on the page.</p>
<pre class="prettyprint">eb.send('vertx.bridge.login', {username: that.username(), password: that.password()}, function (reply) {
    if (reply.status === 'ok') {
      that.sessionID(reply.sessionID);
    } else {
      alert('invalid login');
    }
  });
</pre>
<p>As you can see, it sends a login JSON message to the bridge with the username and password.</p>
<p>When the reply comes back with status <code>ok</code>, it stores the session id which causes knockout to display the "Logged in as... " message.</p>
<p>It's as easy as that.</p>
<h2 id="step-9-persisting-orders">Step 9. Persisting Orders</h2><br/>
<p>Persisting an order is equally simple. We just send a message to the MongoDB persistor component saying we want to store the order.</p>
<p>We also need to tell the bridge to let through requests to persist an order. We also need to add the further constraint that only logged-in users can persist orders.</p>
<p>Edit the web server configuration so it looks like:</p>
<pre class="prettyprint">var webServerConf = {  
  port: 8080,
  host: 'localhost',
  bridge: true,

  // This defines which messages from the client we will let through
  // from the client
  inbound_permitted: [
    // Allow calls to login and authorise
    {
      address: 'vertx.basicauthmanager.login'
    },
    // Allow calls to get static album data from the persistor
    {
      address : 'vertx.mongopersistor',
      match : {
        action : 'find',
        collection : 'albums'
      }
    },
    {
      address : 'vertx.mongopersistor',
      requires_auth : true,  // User must be logged in to send let these through
      match : {
        action : 'save',
        collection : 'orders'
      }
    }
  ],
  outbound_permitted: [ {} ]
};
</pre>
<p>Setting the <code>requires_auth</code> field to <code>true</code> means the bridge will only let through the message if the user is logged in.</p>
<p>Ok, let's take a look at the client side code which sends the order.</p>
<p>Open up <code>web/js/client_app.js</code> again, and look for the function <code>submitOrder</code>.</p>
<pre class="prettyprint">that.submitOrder = function() {

  if (!orderReady()) {
    return;
  }

  var orderItems = ko.toJS(that.items);
  var orderMsg = {
    sessionID: that.sessionID(),
    action: "save",
    collection: "orders",
    document: {
      username: that.username(),
      items: orderItems
    }
  }

  eb.send('vertx.mongopersistor', orderMsg, function(reply) {
    if (reply.status === 'ok') {
      that.orderSubmitted(true);
      // Timeout the order confirmation box after 2 seconds
      // window.setTimeout(function() { that.orderSubmitted(false); }, 2000);
    } else {
      console.error('Failed to accept order');
    }
  });
};
</pre>
<p>This function converts the order into a JSON object, then calls <code>send</code> on the event bus to send it to the database where it will get persisted.</p>
<p>Notice that we add a <code>sessionID</code> field to the message with the session id that was returned when we logged in. The bridge requires this field to be set with a valid session id or the message will not make it through the bridge firewall, since we set the <code>requires_auth</code> field to true in the server side config.</p>
<p>When the reply comes back we tell knockout to display a message.</p>
<p>Everything should be in order, so restart the app again:</p>
<pre class="prettyprint">vertx run app.js
</pre>
<p>Refresh the browser.</p>
<p>Now log-in and add a few items into your cart. Click to the cart tab and click "Submit Order". The message "Your order has been accepted, an email will be on your way to you shortly" should be displayed!</p>
<p>Take a look in the console window of the application. You should see the order has been logged.</p>
<p><img alt="Client Application" src="tutorial_4.png"/></p>
<p><strong> Congratulations! You have just placed an order. </strong></p>
<h2 id="step-11-securing-the-connection">Step 11. Securing the Connection</h2><br/>
<p>So far in this tutorial, all client-server traffic has been over an unsecured socket. That's not a very good idea in a real application since we're sending login credentials and orders.</p>
<p>Configuring Vert.x to use secure sockets is very easy. (For detailed information on configuring HTTPS, please
see the manual).</p>
<p>Edit <code>app.js</code> again, and add the field <code>ssl</code> in the web server config, with the value <code>true</code>.</p>
<pre class="prettyprint">var webServerConf = {  
  port: 8080,
  host: 'localhost',
  ssl: true,
  bridge: true,
  ...
</pre>
<p>You'll also need to provide a key store. The keystore is just a Java keystore which contains the certificate for the server. It can be manipulated using the Java <code>keytool</code> command.      <br/>
</p>
<p>Copy the keystore from the distribution</p>
<pre class="prettyprint">cp $VERTX_HOME/examples/javascript/webapp/server-keystore.jks .
</pre>
<p>Now restart the app again.</p>
<pre class="prettyprint">vertx run app.js
</pre>
<p>And go to your browser. This time point your browser at <code>https://localhost:8080</code>. <em>Note it is <strong>https</strong> not http</em>.</p>
<p><em>You'll initially get a warning from your browser saying the server certificate is unknown. This is to be expected since we haven't told the browser to trust it. You can ignore that for now. On a real server your server cert would probably be from a trusted certificate authority.</em></p>
<p>Now login, and place an order as before.</p>
<p>Easy peasy. <strong>It just works</strong></p>
<h2 id="step-12-scaling-the-application">Step 12. Scaling the application</h2><br/>
<h3 id="scaling-the-web-server">Scaling the web server</h3><br/>
<p>Scaling up the web server part is trivial. Simply start up more instances of the webserver. You can do this by changing the line that starts the <code>vertx.web-server</code> module to something like:</p>
<pre class="prettyprint">// Start 32 instances of the web server!

vertx.deployModule('vertx.web-server-v1.0', webServerConf, 32);
</pre>
<p>(<em>Vert.x is clever here, it notices that you are trying to start multiple servers on the same host and port, and internally it maintains a single listening server, but round robins connections between the various instances</em>.)</p>
<h3 id="more-complex-web-applications">More complex web applications</h3><br/>
<p>In this simple web application, there was no need to write any custom server side modules, but in more complex applications you might want to write your own server side services which can be used by clients (or by other server side code).</p>
<p>Doing this with Vert.x is very straightforward. Here's an example of a trivial server side service which listens on the event bus for messages and sends back the current time to the caller:</p>
<pre class="prettyprint">load('vertx.js');

vertx.eventBus.registerHandler("acme.timeService", function(message, replier) {
    replier({current_time: new Date().getTime()});        
});
</pre>
<p>Save this in <code>time_service.js</code>, and add a line in your <code>app.js</code> to load it on startup.</p>
<p>Then you can just call it from client side JavaScript, or other server side components:</p>
<pre class="prettyprint">eventBus.send("acme.timeService", null, function(reply) {
    console.log("Time is " + reply.current_time);
});
</pre>
<h3 id="packaging-up-your-code-as-a-module">Packaging up your code as a Module</h3><br/>
<p>You can package up your entire application, or just individual Verticles as modules, so they can be easily reused by other applications, or started on the command line more easily.</p>
<p>For an explanation of how to do this, please see the modules manual.  <br/>
</p></div>
      </div>
    </div>
  </div>

</div>

</body>
</html>
